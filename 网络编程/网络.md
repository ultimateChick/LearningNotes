# 网络

## OSI七层模型

应用层

表示层

会话层（可以合并成一个应用层）

**传输层**（通信、TCP

**网络层**（IP

**链路层**（MAC

物理层

![image-20200723115035857](C:\Users\q1367\Desktop\网络编程\OSI图示.png)

## 协议与通信

### **协议：通信建立起来之后，双方沟通使用的语言规范**

比如说HTTP协议eg:

GET / HTTP/1.1 \n

请求头\n\n

请求体

### **通信：指的是双方通过某种方式建立起的，相互为对方服务的一种逻辑**

#### TCP：面向连接的可靠传输

##### 三次握手

![image-20200723102626956](C:\Users\q1367\Desktop\网络编程\三次握手.png)

第一次握手：客户端发送SYN=1，seq=x的数据报给到服务器

第二次：服务器通过数据报中SYN=1直到客户端想要建立连接，他回传的数据报中把SYN和ACK标志位都设置为1，表示服务器也想与客户端建立连接，而且数据报中有确认信息；

ack=x+1代表对客户端发来的syn=x的确认

同时还发出seq=y，这里其实是确认客户端的接收能力是否正常

第三次：客户端收到服务器的回传，置ACK=1，ack=y+1代表正常接收来自服务器的数据报。，发送给服务器，客户端进入established状态

服务器接收到第三个封包，进入established状态



##### 从可靠连接理解tcp

客户端和服务器都要知道双方的接收和发送功能是否正常！

第一次握手：服务器知道了客户端的发送和服务器的接收是正常的

第二次握手：客户端知道了自己的发送和服务器的接收是正常的（第一次握手），同时还知道自己的接受和服务器的发送也是正常的

第三次握手：服务器知道了自己的发送和服务器的接收是正常的

至此，可靠连接建立



##### 建立后做了什么

- 双方操作系统都共通维护一个套接字，以在系统级别标识本次链接
- 双方都为对方的链接，在系统中开辟了资源（内存、缓冲等）为对方服务

##### 四次挥手

理由：因为双方都为对方开辟了一块资源进行服务，所以需要挥手机制来确保双方都释放了资源

这里以客户端主动向服务器发起挥手为例子

第一次挥手：客户端向服务器发送fin数据报

第二次挥手：服务器收到fin数据报，发送ack数据报给客户端，表示服务器知道客户端要断开连接，但是自己还需要做一些处理，暂时还不能fin

第三次挥手：服务器做完善后处理，向客户端发起fin数据报

第四次挥手：客户端收到来自服务器的fin，向服务器发送ack数据报

**客户端在发送ack数据报之后，等待两倍的MSL时间之后会进入close状态**

**服务器在收到客户端的ack数据报之后立马进入close状态**

##### 为什么客户端要等到两倍的msl时间？

**确保正确关闭**

因为自己发送的ack报文可能不被服务器受到，服务器在msl时间之后如果还没收到来自客户端的ack报文要再次发送fin报文，如果这个时候客户端已经关闭，就会造成服务器的状态混乱

最差的情况：自己的ack报文超时，服务器的再次发送的fin报文在msl时间刚好达到，所以客户端需要在等待两倍的msl时间。

**确保上次链接数据报超时**

如果客户端在断开上次的链接之后马上和同样的服务器端口建立连接，如果上次链接还有数据报迟到，那么上次迟到的数据包就会被认为是本次连接的数据。因此客户端需要等待，直到上次链接的所有数据包都超时。

#### Socket：系统维护特定连接的标识（在应用层创建，会先阻塞住

四元组，用以唯一确定特定连接；

四元分别是：客户端ip，客户端端口；服务器ip，服务器端口

这样就可以确认到客户端的唯一进程到服务器的唯一进程建立起链接，相互为对方服务

**通信连接建立起来之后，就是网络IO的相关知识了**

端口号：一个操作系统有65535个，所以理论上一台机器可以向另一台机器的特定进程最多建立起65535个链接

****

**如何模拟高并发量？**

从套接字的原理，我们可以知道这里需要用虚拟ip的方式，从多个虚拟ip的多个端口同时向接受测试的的进程发起链接。

## 网络层

引入：tcp连接中，我们如何把封包正确送达指定的另一端？

**下一跳：next hop**

### 网络的组成

实际上，当前的网络是由很多局域网（网络号）组成的，各个网络号之间通过路由的作用寻访到对方

路由的机制："下一跳"，路由表当中本地网关的地址代表的就是当前请求的下一跳要前往的地址

下一跳机制可以让某个特定请求不需要在整个网络世界中寻路，而只需要把当前请求发送给网关处理即可，极大减少了网络信息的收集、维护、还有寻路的计算工作。

### 网络层三大属性

ip、子网掩码、网关地址、（dns域名解析服务器：用于把字符串形式的请求解析成具体的ip请求）

### IP协议

ip由两个字段组成：网络号、主机号

网络号：由当前的ip地址和子网掩码进行按位与得到的地址，就代表着当前网络的网络号

主机号：ip地址中去除网络号部分剩下的二进制数据所代表的数值，就是当前网络号下的主机号

### 路由表的作用

从一个典型的路由表中，我们起码可以看到

**网络号		网关		掩码**

![image-20200723113546344](C:\Users\q1367\Desktop\网络编程\路由表.png)

#### 如何工作？

1. 对请求的目的进行寻址的时候，首先会进入路由表中进行网关“下一跳”匹配
2. 用掩码对目标ip进行按位与，得到网络号
3. 检查该网络号是否与当前条目记录的网络号一致
4. 如果一致，把请求交给当前记录的网关进行处理（特殊的，如果网关是0.0.0.0，表示在当前网络号中寻找目标主机
5. 如果不一致，则继续找下一条条目
6. 条目中必须包含有一条 **0.0.0.0  默认网关  0.0.0.0**的记录

## 数据链路层

我们的数据报在传送的时候，实际上识别的是MAC地址

比如说我们通过路由表，找到了下一跳的地址，那么我们是把目的地址改变成网关所指向的地址吗，显然不是的，我们的目的地址在整个请求寻路的过程中会一直携带

这里，我们就需要借助链路层的功能，通过不断地携带新的MAC地址，进行寻址

链路层也维护着一张表，这张表是arp表，维护着网关对应的硬件地址

![image-20200723113601985](C:\Users\q1367\Desktop\网络编程\arp表.png)

如果没找到，要走一个arp协议的广播，从局域网中收集ip地址到mac的映射，更新本地维护的arp表

### 列举“下一跳”的基本属性

- 目标ip地址
- 下一跳MAC地址
- 目标端口

### 图示链路层

整个数据报ip地址和目标端口维持不变

每一跳都更换到下一跳的mac地址

链路层解决的就是最近一次跳跃的问题

![image-20200723114218293](C:\Users\q1367\Desktop\网络编程\链路层.png)

## 引申

![image-20200723123452732](C:\Users\q1367\Desktop\网络编程\通信到应用的抽象.png)
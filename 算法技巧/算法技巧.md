# 算法技巧

## 词频统计

由于字符串的词acii在0-255之间，那么我们新建一个int[256]的数组intArr，数组上的每一个索引i位置上的值v，就代表acsii为i的词频为v。

### 比较两个字符串的词频是否相等

如果字符串长度不相等，词频必不相等

字符串长度相等时，第一遍遍历，根据每个字符，++int数组的值

第二遍遍历另一个字符串，判断intArr[  str2CharArr[i]  ]-- == 0

如果等于0，代表着词频不相等；如果遍历结束没出现这种情况，代表词频相等

#### 如果是模式串、匹配串

就先构造模式串的词频数组，每次交给匹配串使用，可以省去很多造数组的开销。

### 词频负债表+滑动窗口解决同源异构字符串的匹配问题

我们把模式串构建的词频数组，当成一个负债表，那么匹配就变成了

**我们需要在匹配串找出第一个连续字串，这个字串上的每一个字符恰好可以满足负债表的需求**

我们用一个长度和模式串长度一致的窗口，在匹配串上滑动，每次滑动的结果，根据负债表中出现负数的加和，得出无效量invalidation。

拥有无效量的窗口不是我们要找的字串，向右滑动，新进来的字符在词频表的对应位置做减法，从左边出去的字符在词频表的对应位置做加法

如果做减法的地方，在减之前，值是<=0的，那么无效量+1

如果做加法的地方，在加之前，值是<0的，name无效量-1

## 从后序遍历的数组结果中重新生成BST

性质：

- 数组的末位一定是当前树的顶点
- 我们可以在数组的中间找到一个特殊的索引M
  - 从这个索引左边（不包含它本身）开始，所有的数值都小于顶点
  - 从这个索引右边（包含它本身）开始，所有的数值都大于定点
- 那么，我们有
  - [L,M)是当前顶点的左子树内容
  - [M,R)是当前定点的右子树内容
- 因此我们可以递归建立BST，把步骤抽象成
  - node.left=f(L,M)
  - node.right=f(M,R)
  - f()代表着我们识别左右子树的一趟过程
- 优化：
- 我们可以遍历从前面的数组中找到这个特殊M
- 优化的方式就是使用二分法！可以使得时间复杂度控制在nlogn级别

## 业务场景：生成对于任意i<k<j,都满足arr[i]+arr[j]!=arr[k]*2的arr

原理：奇数+偶数!=自然数*2

这里无非是要满足arr[i]为奇数,arr[j]为偶数

我们从种子int[]{1}出发

按照奇数生成策略和偶数生成策略（eg：arr[i]映射到第arr[i]个奇/偶数）

当我们经过两轮生成合并会得到

{奇数，奇数，偶数，偶数}

无论怎么选择ijk，都满足奇数+偶数！=2*自然数的规范

从这个种子出发，就能满足

## 从数组出发，每个索引位置上的数都和其他位置，包括自己，产生（v1,v2）的数对，并按照v1、v2的优先级排序，求问第k个数对的值

实质：分别找到v1、v2在数组中的有序索引

假设数组长度为M

那么v1在数组中的索引I应当为：(k-1)/M

v2如何确定？

假设我们拿到了I，确定了v1的值

设想：数组中有N个和v1相同的值

那么就有I-L个比v1小

R-I-N个比v1大

要找到第k个数对的v2

首先可以排除(I-L)*M个数据，他们的v1比arr[I]小

那么就还有k-(I-L)*M个数据需要确认

在N个和v1相同的情况下，在整个数组以arr[I]为v1的时候，对每个索引为上的值，必然有N个(arr[I],xxx)的数对，共N*M个

那我们就是要找到NM个当中的第k-(I-L)*M个

公式也很简单，v2的索引O就是

O=(k-(I-L)*M)/N

结论：

I = (k-1)/M

O = (k-(I-L)*M)/N

### 最优秀的解法

BFPRT算法专门解决无序数组中第k个数值的查找，时间复杂度是O(N)

这块也是热门的TOP-k问题

我们只需要利用BFPRT算法找到I和O两个位置上的值即可

### 一般解法

运用排序算法得到有序的arr，再根据索引公式取到v1v2

这里的时间复杂度是O(nlogn)

## 字符串子串原地交换问题


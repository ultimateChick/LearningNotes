# Linux下的系统IO原理

### VFS(虚拟文件系统)

系统内核有一个VFS，一个目录树

树上的不同节点映射到不同的物理位置，不同的位置可以是具体的不同的文件系统

Windows可以说是具体的文件系统，Linux虚拟文件系统解耦了不同IO设备的具体实现的区别。可以使得目录树趋向于稳定。 

#### iNode

就是文件的id，每一个文件打开都会有一个唯一的iNode号对应到它，

#### pageCache

默认是4k，程序要读取文件，由内核在中间建立联系，维护一个pageCache，里面是我们想要读的数据，如果程序对文件内容进行了修改，内核就会给相应内容标记一个 **dirty** ，有dirty就有flush的一个过程，书写到磁盘当中去，这个书写的形式就是我们的IO模型。

dirty是kernel是对上层所有打开的文件统一的管理，不针对某一个文件。对脏页的管理是统一的

#### fd（文件描述符），交给程序用的，

我们知道，内核会通过pageCache统一给上层多个应用程序提供同一文件的访问，那么不同应用程序所需要的文件的偏移量应该是不一样的，因此内核给每个程序都维护了一个fd，fd中记录一个指针seek，用以标识当前程序对文件操作的偏移量。因此每个程序都能读取到自己需要读取的那个pageCache。

tip：如果两个程序需要修改同一pageCache的内容，就必须要加锁了。

这就和java当中的迭代器模式很像，迭代器模式给每个线程都维护一个游标，负责记录当前该线程对对象的迭代进度。

#### 文件类型

​	- : 普通文件（可执行、图片、文本

​	d : 目录

​	l : 链接

​	b : 块设备 

​    c : 字符设备

​    s : socket

​    p : pipeline

​    [eventpoll] : epoll提供的内存区域

##### 硬链接

它是系统中到具体的iNode（物理区域）的引用，指向同一位置的硬链接是一样的

##### 软连接

好似windows下的快捷方式，他们是各自独立的文件（INode号不同）



任何程序都有：

0：标准输入

1：标准输出

2：报错输出



在/proc目录下，它是内核的映射目录，内核的相关属性都映射成文件存在于其中

每个进程的相关属性都被存放在其pid对应的文件夹下面

其中fd文件夹内存放着当前进程的全部文件描述符

有了文件描述符，我们就可以进行重定向

重定向：本质不是命令，而是一种机制

0<  1>:前者表示标准输入的重定向 后者表示标准输出的重定向

在一些命令中默认是用标准输入输出写死的，可以用这样的方式来使得他们的输入和输出来源发生改变



#### 管道： |

把管道前的基本输出作为后面命令的基本输入

##### 父子进程

pstree可以查看当前系统的进程和进程的继承关系

##### 环境变量

普通的变量在进程间有隔离

export声明的变量具有进程间的导出性，可以使这种变量变成环境变量

##### |的特性

- 管道其实是对着左右各起了一个子进程，把前面的标准输出通过管道的作用输入到后面的标准输入。
- echo $$ | cat :输出的仍然是当前进程的id，这里bash先看到$$，用当前进程id做了变量的置换，再看到管道符，就把当前的进程id交给cat了。
- echo $BASHPID | cat：输出的是管道起的子进程的id
- 这是因为$$的优先级高于管道，$BASHPID的优先级小于管道

#### PageCache

![image-20200811000337175](C:\Users\q1367\Desktop\操作系统的底层知识\images\image-20200811000337175.png)

PageCache的本质是内核对加载到内核的程序的一层抽象，操作系统为了方便管理程序从磁盘到内存的加载使用了page的概念，一个page默认是4kB。磁盘按4kB对齐，内存中的空间在OS的内核控制下也是以4kB分块用以数据存储。

我们在操作系统中打开了很多进程，这些进程在OS的作用下为了优化内存占用不做全量加载，而是分页把程序或者文件的数据加载到内存中，加载到内存中的page就称为pageCache，对于需要使用到的但是没有在内存中的就会产生缺页异常中断优先把缺少的page从硬盘中加载到内存中来。

而每个进程都各自维护一个文件描述符，对于不同进程中使用到的同一文件其实都可能指向内存中的同一块pageCache，在fd中维护的seek参数代表当前进程对于文件使用的偏移量。这样做的好处是不用在内存中重复加载同一文件的page，优化了对内存空间的使用。

在使用过程中还有涉及到对数据的修改和淘汰的环节，我们IO对文件的修改首先是对内存中pageCache的修改，这时候pageCache会被标记为dirty，因为一般不急于立马写回到硬盘中持久化起来（持久化涉及IO可能影响性能，这里还有延时、数据丢失等问题，所以我们添加抽象层解决了一些问题，带来了新的一致性、可靠性等等问题）；而淘汰的方案最常用的就是LRU算法，也就是当内存空间需要出清pageCache的时候会优先把最长时间没有使用到的pageCache从内存中淘汰出去。

### 脏数据处理

```
vm.dirty_background_bytes = 0
vm.dirty_background_ratio = 10 //脏数据占用的比值10%开始，内核在后台开始持久化过程
vm.dirty_bytes = 0
vm.dirty_ratio = 30 //这里是前台阻塞，比后台方式更暴力，但是可以保证出清内存脏数据
vm.dirty_expire_centisecs = 3000 // 脏页的生命周期
vm.dirty_writeback_centisecs = 500 // 

```

pageCache为了优化IO性能，但有潜在的丢失数据的风险。

### 从IO层级理解直接IO和bufferedIO的性能区别

在java中我们直接使用File输入输出流，对于每次执行write操作，都会进行一次软中断进行syscall，这极大地降低了系统的吞吐量，大量的事件被浪费在了用户态和内核态的切换上面；比如说需要保护线程现场到缓存，执行完后恢复现场等消耗CPU指令时间的大量操作

而buffered会先把数据存储到我们指定好的大小，再去执行系统调用，提高了吞吐量。



